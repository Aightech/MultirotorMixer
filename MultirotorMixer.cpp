/****************************************************************************
 *
 *   Copyright (c) 2012-2018 PX4 Development Team. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name PX4 nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

/**
 * @file mixer_multirotor.cpp
 *
 * Multi-rotor mixers.
 */

#include "MultirotorMixer.hpp"

#include <float.h>
#include <cstring>
#include <cstdio>

#include <mathlib/mathlib.h>

//#define YAW_TILT_CONTROLED 1

#ifdef MIXER_MULTIROTOR_USE_MOCK_GEOMETRY
enum class MultirotorGeometry : MultirotorGeometryUnderlyingType {
    QUAD_X,
    MAX_GEOMETRY
};
namespace
{
const MultirotorMixer::Rotor _config_quad_x[] = {
    { -0.707107,  0.707107,  1.000000,  1.000000 },
    {  0.707107, -0.707107,  1.000000,  1.000000 },
    {  0.707107,  0.707107, -1.000000,  1.000000 },
    { -0.707107, -0.707107, -1.000000,  1.000000 },
};
const MultirotorMixer::Rotor *_config_index[] = {
    &_config_quad_x[0]
};
const unsigned _config_rotor_count[] = {4};
const char *_config_key[] = {"4x"};
}

#else

// This file is generated by the px_generate_mixers.py script which is invoked during the build process
// #include "mixer_multirotor.generated.h"
#ifdef YAW_TILT_CONTROLED
#include "mixer_multirotor_tilt.generated.h"    //pseudo inverse computed without the yaw
#else
#include "mixer_multirotor.generated.h"
#endif

#endif /* MIXER_MULTIROTOR_USE_MOCK_GEOMETRY */


//#define debug(fmt, args...)	do { } while(0)
#define debug(fmt, args...)	do { printf("[mixer] " fmt "\n", ##args); } while(0)
//#include <debug.h>
//#define debug(fmt, args...)	syslog(fmt "\n", ##args)

MultirotorMixer::MultirotorMixer(ControlCallback control_cb, uintptr_t cb_handle, MultirotorGeometry geometry,float Ixx,float Iyy,float Izz) :
    MultirotorMixer(control_cb, cb_handle, _config_index[(int)geometry], _config_geometries_index[(int)geometry], _config_rotor_count[(int)geometry])
{
    //_idle_speed = -1.0f + idle_speed * 2.0f;	/* shift to output range here to avoid runtime calculation */

    _mass = _config_mass[(int)geometry];    //get the drone mass from the generated header
    _Ct = _config_rotor_Ct[(int)geometry];  //get the drone lift/thrust from the generated header
    _Cm = _config_rotor_Cm[(int)geometry];  //get the drone drag/moment coeficient from the generated header

    _thrust_ctrl_input_to_force = 2.0f*_mass*9.81f; //compute the thrust coef to ensure stationary fly with a command of 0.5

    _Ixx =Ixx;
    _Iyy =Iyy;
    _Izz =Izz;

    debug("%f %f %f", double(_Ixx), double(_Iyy), double(_Izz));



}

MultirotorMixer::MultirotorMixer(ControlCallback control_cb, uintptr_t cb_handle, const Rotor *rotors, const Geometry *geo,
                 unsigned rotor_count) :
    Mixer(control_cb, cb_handle),
    _rotor_count(rotor_count),
    _rotors(rotors),
    _geometry(geo),
    _outputs_prev(new float[_rotor_count]),
    _tmp_array(new float[_rotor_count])
{
    for (unsigned i = 0; i < _rotor_count; ++i) {
        _outputs_prev[i] = _idle_speed;
    }
}

MultirotorMixer::~MultirotorMixer()
{
    delete[] _outputs_prev;
    delete[] _tmp_array;
}

MultirotorMixer *
MultirotorMixer::from_text(Mixer::ControlCallback control_cb, uintptr_t cb_handle, const char *buf, unsigned &buflen)
{
    MultirotorGeometry geometry = MultirotorGeometry::MAX_GEOMETRY;
    char geomname[16];
    int s[4];
    int used;

    /* enforce that the mixer ends with a new line */
    if (!string_well_formed(buf, buflen)) {
        return nullptr;
    }

    if (sscanf(buf, "R: %15s %d %d %d %d%n", geomname, &s[0], &s[1], &s[2], &s[3], &used) != 5) {
        debug("multirotor parse failed on '%s'", buf);
        return nullptr;
    }

    if (used > (int)buflen) {
        debug("OVERFLOW: multirotor spec used %d of %u", used, buflen);
        return nullptr;
    }

    buf = skipline(buf, buflen);

    if (buf == nullptr) {
        debug("no line ending, line is incomplete");
        return nullptr;
    }

    debug("remaining in buf: %d, first char: %c", buflen, buf[0]);

    for (MultirotorGeometryUnderlyingType i = 0; i < (MultirotorGeometryUnderlyingType)MultirotorGeometry::MAX_GEOMETRY;
         i++) {
        if (!strcmp(geomname, _config_key[i])) {
            geometry = (MultirotorGeometry)i;
            break;
        }
    }

    if (geometry == MultirotorGeometry::MAX_GEOMETRY) {
        debug("unrecognised geometry '%s'", geomname);
        return nullptr;
    }

    debug("adding multirotor mixer '%s'", geomname);

    return new MultirotorMixer(
               control_cb,
               cb_handle,
               geometry,
               s[0]/1000.f,
               s[1]/1000.f,
               s[2]/1000.f); //corresponds to the last control input, i.e thrust or idle speed
}

float
MultirotorMixer::compute_desaturation_gain(const float *desaturation_vector, const float *outputs,
        saturation_status &sat_status, float min_output, float max_output) const
{
    float k_min = 0.f;
    float k_max = 0.f;

    for (unsigned i = 0; i < _rotor_count; i++) {
        // Avoid division by zero. If desaturation_vector[i] is zero, there's nothing we can do to unsaturate anyway
        if (fabsf(desaturation_vector[i]) < FLT_EPSILON) {
            continue;
        }

        if (outputs[i] < min_output) {
            float k = (min_output - outputs[i]) / desaturation_vector[i];

            if (k < k_min) { k_min = k; }

            if (k > k_max) { k_max = k; }

            sat_status.flags.motor_neg = true;
        }

        if (outputs[i] > max_output) {
            float k = (max_output - outputs[i]) / desaturation_vector[i];

            if (k < k_min) { k_min = k; }

            if (k > k_max) { k_max = k; }

            sat_status.flags.motor_pos = true;
        }
    }

    // Reduce the saturation as much as possible
    return k_min + k_max;
}

void
MultirotorMixer::minimize_saturation(const float *desaturation_vector, float *outputs,
                     saturation_status &sat_status, float min_output, float max_output, bool reduce_only) const
{
    float k1 = compute_desaturation_gain(desaturation_vector, outputs, sat_status, min_output, max_output);

    if (reduce_only && k1 > 0.f) {
        return;
    }

    for (unsigned i = 0; i < _rotor_count; i++) {
        outputs[i] += k1 * desaturation_vector[i];
    }

    // Compute the desaturation gain again based on the updated outputs.
    // In most cases it will be zero. It won't be if max(outputs) - min(outputs) > max_output - min_output.
    // In that case adding 0.5 of the gain will equilibrate saturations.
    float k2 = 0.5f * compute_desaturation_gain(desaturation_vector, outputs, sat_status, min_output, max_output);

    for (unsigned i = 0; i < _rotor_count; i++) {
        outputs[i] += k2 * desaturation_vector[i];
    }
}


void
MultirotorMixer::mix_airmode_disabled(float moment_roll, float moment_pitch, float moment_yaw, float thrust, float *squared_rotor_spd)
{
    //By aightech: In this function you can compute the relation between the moment/thrust and the rotor squared speed.
    //By aightech: all the variable are in SI units


    //By aightech: ######### PX4 original computation ###########
    //By aightech: Almost equivalent to a matrix multiplication between the pseudo inverse of the allocation matrix and the moment/thrust vector.

    // Airmode disabled: never allow to increase the thrust to unsaturate a motor
    // Mix without yaw
    for (unsigned i = 0; i < _rotor_count; i++) {

        squared_rotor_spd[i] = moment_roll * _rotors[i].rotor_roll_allocation_coeff +
                 moment_pitch * _rotors[i].rotor_pitch_allocation_coeff +
                 thrust * _rotors[i].thrust_allocation_coeff;

        // Thrust will be used to unsaturate if needed
        _tmp_array[i] = _rotors[i].thrust_allocation_coeff;
    }

    // only reduce thrust
    minimize_saturation(_tmp_array, squared_rotor_spd, _saturation_status, _min_speed2, _max_speed2, true);

    // Reduce roll/pitch acceleration if needed to unsaturate
    for (unsigned i = 0; i < _rotor_count; i++) {
        _tmp_array[i] = _rotors[i].rotor_roll_allocation_coeff;
    }

    minimize_saturation(_tmp_array, squared_rotor_spd, _saturation_status, _min_speed2, _max_speed2);

    for (unsigned i = 0; i < _rotor_count; i++) {
        _tmp_array[i] = _rotors[i].rotor_pitch_allocation_coeff;
    }

    minimize_saturation(_tmp_array, squared_rotor_spd, _saturation_status, _min_speed2, _max_speed2);

    // Mix yaw independently
    mix_yaw(moment_yaw, squared_rotor_spd);

}

void MultirotorMixer::mix_yaw(float yaw, float *outputs)
{
    // Add yaw to outputs
    for (unsigned i = 0; i < _rotor_count; i++) {
        outputs[i] += yaw * _rotors[i].rotor_yaw_allocation_coeff;

        // Yaw will be used to unsaturate if needed
        _tmp_array[i] = _rotors[i].rotor_yaw_allocation_coeff;
    }

    // Change yaw acceleration to unsaturate the outputs if needed (do not change roll/pitch),
    // and allow some yaw response at maximum thrust
    minimize_saturation(_tmp_array, outputs, _saturation_status, _min_speed2, _max_speed2);

    for (unsigned i = 0; i < _rotor_count; i++) {
        _tmp_array[i] = _rotors[i].thrust_allocation_coeff;
    }

    // reduce thrust only
    minimize_saturation(_tmp_array, outputs, _saturation_status, _min_speed2, _max_speed2, true);
}


void
MultirotorMixer::mix_yaw_tilt_controlled(float moment_roll, float moment_pitch, float moment_yaw, float thrust, float *squared_rotor_spd,  float *tilt_motor_pos)
{
    // Mix without yaw
    for (unsigned i = 0; i < _rotor_count; i++) {
        squared_rotor_spd[i] = moment_roll * _rotors[i].rotor_roll_allocation_coeff +
                 moment_pitch * _rotors[i].rotor_pitch_allocation_coeff +
                 thrust * _rotors[i].thrust_allocation_coeff;
        // Thrust will be used to unsaturate if needed
        _tmp_array[i] = _rotors[i].thrust_allocation_coeff;
    }
    // only reduce thrust
    minimize_saturation(_tmp_array, squared_rotor_spd, _saturation_status, _min_speed2, _max_speed2, true);
    // Reduce roll/pitch acceleration if needed to unsaturate
    for (unsigned i = 0; i < _rotor_count; i++)
        _tmp_array[i] = _rotors[i].rotor_roll_allocation_coeff;
    minimize_saturation(_tmp_array, squared_rotor_spd, _saturation_status, _min_speed2, _max_speed2);
    for (unsigned i = 0; i < _rotor_count; i++)
        _tmp_array[i] = _rotors[i].rotor_pitch_allocation_coeff;
    minimize_saturation(_tmp_array, squared_rotor_spd, _saturation_status, _min_speed2, _max_speed2);


    //Compute angle tilt to control the yaw
    float sum1=0,sum2=0;
    float sign[4] = {-1,1,1,-1};
    for(unsigned i =0;i<_rotor_count;i++){
        sum1+= _geometry[i].dir*squared_rotor_spd[i];       // \sum_{i=1}^{4}(-1)^i.\Bar{\omega}_i^2
        //          |                  |
        //          |                  '-> rotor squared rotation speed <=> \Bar{\omega}_i^2
        //          '-> Counter Clock Wise rotation: 1   Clock Wise rotation: -1

        sum2+= sign[i]*squared_rotor_spd[i]*_geometry[i].j; // \sum_{i=1}^{4} (-1 if left motor else 1 ).\sin\theta_i.\Bar{\omega}_i^2
        //       |               |              |
        //       |               |              '-> motor position along the j axis <=> d*\sin\theta_i
        //       |               '-> rotor squared rotation speed <=> \Bar{\omega}_i^2
        //       '-> left motor: -1  right motot: 1
    }


    float tilt = (moment_yaw - _Cm*sum1)/(_Ct*sum2); //\frac{M_{\vec{k}} - K_D \sum_{i=1}^{4}(-1)^i \Bar{\omega}_i^2}{d.K_l.\sum_{i=1}^{4}(-1)^{\llfloor \frac{i-1}{2} \rrfloor} \sin\theta_i\Bar{\omega}_i^2}
    //                               |
    //                               '-> seems to be always equal to 0

    for (unsigned i = 0; i < _rotor_count; i++)
        tilt_motor_pos[i]= sign[i]*tilt/_tilt_motor_scaling; // output the tilt angle with the right orientation depending of right/left tilt motor

}

unsigned
MultirotorMixer::mix(float *output_sent_to_driver, unsigned space)
{
    //Only one array is used but for readibility we use different name depending on the process step.
    float *squared_rotor_spd = output_sent_to_driver;
    float *rotor_spd = output_sent_to_driver;

    if (space < _rotor_count) {
        return 0;
    }

    //debug("%f ", double(get_control(0, 3)));

    float torque_roll    = _Ixx  * get_control(0, 0);
    float torque_pitch   = _Iyy  * get_control(0, 1);
    float torque_yaw     = _Izz  *  math::constrain(get_control(0, 2) , -1.0f, 1.0f);
    //        |              |           |
    //        |              |           '-> angular acceleretion setpoint
    //        |              '-> Inertia of the drone
    //        '-> Torques setpoint

    float thrust  = _thrust_ctrl_input_to_force  * get_control(0, 3);



    // clean out class variable used to capture saturation
    _saturation_status.value = 0;

    // Do the mixing using the strategy given by the current Airmode configuration
#ifdef YAW_TILT_CONTROLED
    mix_yaw_tilt_controlled(torque_roll, torque_pitch, torque_yaw, thrust, squared_rotor_spd, squared_rotor_spd+_rotor_count);
#else
    mix_airmode_disabled(torque_roll, torque_pitch, torque_yaw, thrust, squared_rotor_spd);
#endif


    //By aightech: transform the rotor speed into pwm
    // output_sent_to_driver has to be between -1 and 1.
    //When -1, the duty cycle sent to the motor is 0.
    //When 0, , the duty cycle sent to the motor is 0.5.
    //When 1, the duty cycle sent to the motor is 1.
    // THIS IS WERE WE HAVE CONTROL OVER THE DUTY CYCLE
    // Then it is processed by the drivers.
    for (unsigned i = 0; i < _rotor_count; i++)
    {
        //By aightech:: root squared the rotor speed.
        rotor_spd[i] = 300;//sqrt(math::constrain(squared_rotor_spd[i],0.0f,fabsf(squared_rotor_spd[i])));

        //debug("%f", double(rotor_spd[i]));
        float A=1379.5;
        float B=-89.f;
        output_sent_to_driver[i] = math::constrain(2.0f*rotor_spd[i]/A-1.0f -2*B/A ,-1.0f,1.0f);//math::constrain((rotor_spd[i]/motor_constant_in_rad_sec_per_volt/battery_voltage)*2.0f-1.0f,-1.0f,1.0f);

    }


#ifdef YAW_TILT_CONTROLED
    return 2*_rotor_count; // each rotors has been mixed + each tilt motors
#else
    return _rotor_count; // each rotors has been mixed + each tilt motors
#endif
}

