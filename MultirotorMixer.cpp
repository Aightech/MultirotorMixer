/****************************************************************************
 *
 *   Copyright (c) 2012-2018 PX4 Development Team. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name PX4 nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

/**
 * @file mixer_multirotor.cpp
 *
 * Multi-rotor mixers.
 */

#include "MultirotorMixer.hpp"

#include <float.h>
#include <cstring>
#include <cstdio>



#ifdef MIXER_MULTIROTOR_USE_MOCK_GEOMETRY
enum class MultirotorGeometry : MultirotorGeometryUnderlyingType {
	QUAD_X,
	MAX_GEOMETRY
};
namespace
{
const MultirotorMixer::Rotor _config_quad_x[] = {
	{ -0.707107,  0.707107,  1.000000,  1.000000 },
	{  0.707107, -0.707107,  1.000000,  1.000000 },
	{  0.707107,  0.707107, -1.000000,  1.000000 },
	{ -0.707107, -0.707107, -1.000000,  1.000000 },
};
const MultirotorMixer::Rotor *_config_index[] = {
	&_config_quad_x[0]
};
const unsigned _config_rotor_count[] = {4};
const char *_config_key[] = {"4x"};
}

#else

// This file is generated by the px_generate_mixers.py script which is invoked during the build process
// #include "mixer_multirotor.generated.h"
#include "mixer_multirotor_normalized.generated.h"

#endif /* MIXER_MULTIROTOR_USE_MOCK_GEOMETRY */


//#define debug(fmt, args...)	do { } while(0)
#define debug(fmt, args...)	do { printf("[mixer] " fmt "\n", ##args); } while(0)
//#include <debug.h>
//#define debug(fmt, args...)	syslog(fmt "\n", ##args)

MultirotorMixer::MultirotorMixer(ControlCallback control_cb, uintptr_t cb_handle, MultirotorGeometry geometry,
				 float roll_scale, float pitch_scale, float yaw_scale, float idle_speed) :
	MultirotorMixer(control_cb, cb_handle, _config_index[(int)geometry], _config_rotor_count[(int)geometry])
{
	_roll_scale = roll_scale;
	_pitch_scale = pitch_scale;
	_yaw_scale = yaw_scale;
	_idle_speed = -1.0f + idle_speed * 2.0f;	/* shift to output range here to avoid runtime calculation */
}

MultirotorMixer::MultirotorMixer(ControlCallback control_cb, uintptr_t cb_handle, const Rotor *rotors,
				 unsigned rotor_count) :
	Mixer(control_cb, cb_handle),
	_rotor_count(rotor_count),
	_rotors(rotors),
	_outputs_prev(new float[_rotor_count]),
	_tmp_array(new float[_rotor_count])
{
	for (unsigned i = 0; i < _rotor_count; ++i) {
		_outputs_prev[i] = _idle_speed;
	}
    set_structure_params();
}

MultirotorMixer::~MultirotorMixer()
{
	delete[] _outputs_prev;
	delete[] _tmp_array;
}

MultirotorMixer *
MultirotorMixer::from_text(Mixer::ControlCallback control_cb, uintptr_t cb_handle, const char *buf, unsigned &buflen)
{
	MultirotorGeometry geometry = MultirotorGeometry::MAX_GEOMETRY;
	char geomname[8];
	int s[4];
    int used;
	/* enforce that the mixer ends with a new line */
	if (!string_well_formed(buf, buflen)) {
		return nullptr;
	}


	if (sscanf(buf, "R: %7s %d %d %d %d%n", geomname, &s[0], &s[1], &s[2], &s[3], &used) != 5) {
		debug("multirotor parse failed on '%s'", buf);
		return nullptr;
	}
    debug("R: %s %d %d %d %d",geomname, s[0], s[1], s[2], s[3]);

	if (used > (int)buflen) {
		debug("OVERFLOW: multirotor spec used %d of %u", used, buflen);
		return nullptr;
	}

	buf = skipline(buf, buflen);

	if (buf == nullptr) {
		debug("no line ending, line is incomplete");
		return nullptr;
	}

	debug("remaining in buf: %d, first char: %c", buflen, buf[0]);

	for (MultirotorGeometryUnderlyingType i = 0; i < (MultirotorGeometryUnderlyingType)MultirotorGeometry::MAX_GEOMETRY;
	     i++) {
		if (!strcmp(geomname, _config_key[i])) {
			geometry = (MultirotorGeometry)i;
			break;
		}
	}

	if (geometry == MultirotorGeometry::MAX_GEOMETRY) {
		debug("unrecognised geometry '%s'", geomname);
		return nullptr;
	}

	debug("adding multirotor mixer '%s'", geomname);

	return new MultirotorMixer(
		       control_cb,
		       cb_handle,
		       geometry,
		       s[0] / 10000.0f,
		       s[1] / 10000.0f,
		       s[2] / 10000.0f,
		       s[3] / 10000.0f);
}



void
MultirotorMixer::set_structure_params()
{
    // Allocation Matrix(4*n) setup
    //     |        tau_l           tau_l           tau_l    ...       tau_l      |
    // D = | -l*tau_l*sin_t1 -l*tau_l*sin_t2 -l*tau_l*sin_t3 ... -l*tau_l*sin_tn  |
    //     |  l*tau_l*cos_t1  l*tau_l*cos_t2  l*tau_l*cos_t3 ...  l*tau_l*cos_tn  |
    //     |        tau_d          -tau_d           tau_d    ... (-1)^(n+1)*tau_d |
    for(int i =0; i<4; i++)
    {
        _structure.D(0,i) = _structure.tau_lift;
        _structure.D(1,i) = - _structure.tau_lift*_structure.arm_length*sin(_structure.arm_angle[i]);
        _structure.D(2,i) = _structure.tau_lift*_structure.arm_length*cos(_structure.arm_angle[i]);
        _structure.D(3,i) = _structure.tau_drag*(1-(2*(i%2)));
    }

    // X = ( thrust roll_torque pitch_torque yaw_torque )^t
    // Y = ( w1  w2  w3 ... wn )^t
    //
    // X = D*Y
    // => Y = (D^t.D)^-1.D^t * X
    int precision_helper = 1000;//avoid exceeding float precision
    _structure.Dinv = matrix::inv<float,_MULTIROTOR_COUNT_>(_structure.D.T()*precision_helper*_structure.D*precision_helper)*_structure.D.T()*precision_helper*precision_helper;

    // linear parameter to pass from rad/sec to px4 rotation coef...
    _A_speed =  1.0f/500.0f;
    _B_speed = -60.0f/50.0f;
}

bool
MultirotorMixer::compute_rotor_speed(float roll, float pitch, float yaw, float thrust, float *outputs, bool safe, int n)
{
    //if the iteration is too long, abort and put no speed ...
    if(n>0 || !safe)
    {
        matrix::Matrix<float, _MULTIROTOR_COUNT_, 1> Y;
        float arr_x[4] = {thrust, roll, pitch, yaw};
        matrix::Matrix<float, 4, 1> X(arr_x);
        //X=DY
        Y = _structure.Dinv * X;

        for(unsigned i =0; i < _rotor_count; i++)
        {

            //normale case
            if(!safe || (Y(_structure.lookup_table[i],0)>_structure.min_speed-2 && Y(_structure.lookup_table[i],0)< _structure.max_speed*_structure.max_speed+2))
                outputs[i] = sqrt(Y(_structure.lookup_table[i],0));
            else
            { // maybe not enough or too much thrust so apply the require thrust to reach the output limit
                float d;
                if(Y(_structure.lookup_table[i],0)<0)
                    d = _structure.min_speed;//min rotation speed
                else
                    d = _structure.max_speed*_structure.max_speed;//max_rotation speed

                //compute the require thrust
                for(unsigned j = 1; j < 4; j++)
                    d -= arr_x[j]*_structure.Dinv(_structure.lookup_table[i],j);
                arr_x[0] = d/_structure.Dinv(_structure.lookup_table[i],0);


                debug("oups");

                // recompute the adequate rotation speed
                return compute_rotor_speed(roll, pitch, yaw, arr_x[0], outputs,true,n-1);
            }
        }
        return true;
    }
    else
    {
        for(unsigned i =0; i < _rotor_count; i++)
            outputs[i] = 0;
        //debug("Couldn't find solution");
        return false;
    }
}
void
MultirotorMixer::compute_outputs(float *outputs)
{
    //apply the linear transformation to each motor output
    for(unsigned i =0; i < _rotor_count; i++)
        outputs[i] = _A_speed*outputs[i]+ _B_speed;
}

unsigned
MultirotorMixer::mix(float *outputs, unsigned space)
{
	if (space < _rotor_count) {
		return 0;
    }

    //get the controle and scale it to get approximated SI units
    float roll    = _dynamic.roll_scale   * math::constrain(get_control(0, 0) * _roll_scale, -1.0f, 1.0f);
    float pitch   = _dynamic.pitch_scale  * math::constrain(get_control(0, 1) * _pitch_scale, -1.0f, 1.0f);
    float yaw     = _dynamic.yaw_scale    * math::constrain(get_control(0, 2) * _yaw_scale, -1.0f, 1.0f);
    float thrust  = _dynamic.thrust_scale * math::constrain(get_control(0, 3), 0.0f, 1.0f);

    // clean out class variable used to capture saturation
    _saturation_status.value = 0;

    //compute the rotor speed, with safe constraint first and without if safe doesn't work
    if(!compute_rotor_speed(roll, pitch, yaw, thrust, outputs))
        compute_rotor_speed(roll, pitch, yaw, thrust, outputs,false);

    //debug("r:%f \t p:%f \t y:%f \t t:%f \t %f \t %f \t %f \t %f", double(roll), double(pitch), double(yaw), double(thrust), double(outputs[0]), double(outputs[1]), double(outputs[2]), double(outputs[3]));
    compute_outputs(outputs);

    // this will force the caller of the mixer to always supply new slew rate values, otherwise no slew rate limiting will happen
    _delta_out_max = 0.0f;

	return _rotor_count;
}
