/****************************************************************************
 *
 *   Copyright (c) 2012-2018 PX4 Development Team. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name PX4 nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

/**
 * @file mixer_multirotor.cpp
 *
 * Multi-rotor mixers.
 */

#include "MultirotorMixer.hpp"

#include <float.h>
#include <cstring>
#include <cstdio>

#include <mathlib/mathlib.h>

#ifdef MIXER_MULTIROTOR_USE_MOCK_GEOMETRY
enum class MultirotorGeometry : MultirotorGeometryUnderlyingType {
    QUAD_X,
    MAX_GEOMETRY
};
namespace
{
const MultirotorMixer::Rotor _config_quad_x[] = {
    { -0.707107,  0.707107,  1.000000,  1.000000 },
    {  0.707107, -0.707107,  1.000000,  1.000000 },
    {  0.707107,  0.707107, -1.000000,  1.000000 },
    { -0.707107, -0.707107, -1.000000,  1.000000 },
};
const MultirotorMixer::Rotor *_config_index[] = {
    &_config_quad_x[0]
};
const unsigned _config_rotor_count[] = {4};
const char *_config_key[] = {"4x"};
}

#else

// This file is generated by the px_generate_mixers.py script which is invoked during the build process
// #include "mixer_multirotor.generated.h"
#include "mixer_multirotor.generated.h"

#endif /* MIXER_MULTIROTOR_USE_MOCK_GEOMETRY */


//#define debug(fmt, args...)	do { } while(0)
#define debug(fmt, args...)	do { printf("[mixer] " fmt "\n", ##args); } while(0)
//#include <debug.h>
//#define debug(fmt, args...)	syslog(fmt "\n", ##args)

MultirotorMixer::MultirotorMixer(ControlCallback control_cb, uintptr_t cb_handle, MultirotorGeometry geometry,float idle_speed) :
    MultirotorMixer(control_cb, cb_handle, _config_index[(int)geometry], _config_rotor_count[(int)geometry])
{
    _idle_speed = -1.0f + idle_speed * 2.0f;	/* shift to output range here to avoid runtime calculation */

}

MultirotorMixer::MultirotorMixer(ControlCallback control_cb, uintptr_t cb_handle, const Rotor *rotors,
                 unsigned rotor_count) :
    Mixer(control_cb, cb_handle),
    _rotor_count(rotor_count),
    _rotors(rotors),
    _outputs_prev(new float[_rotor_count]),
    _tmp_array(new float[_rotor_count])
{
    for (unsigned i = 0; i < _rotor_count; ++i) {
        _outputs_prev[i] = _idle_speed;
    }
}

MultirotorMixer::~MultirotorMixer()
{
    delete[] _outputs_prev;
    delete[] _tmp_array;
}

MultirotorMixer *
MultirotorMixer::from_text(Mixer::ControlCallback control_cb, uintptr_t cb_handle, const char *buf, unsigned &buflen)
{
    MultirotorGeometry geometry = MultirotorGeometry::MAX_GEOMETRY;
    char geomname[16];
    int s[4];
    int used;

    /* enforce that the mixer ends with a new line */
    if (!string_well_formed(buf, buflen)) {
        return nullptr;
    }

    if (sscanf(buf, "R: %15s %d %d %d %d%n", geomname, &s[0], &s[1], &s[2], &s[3], &used) != 5) {
        debug("multirotor parse failed on '%s'", buf);
        return nullptr;
    }

    if (used > (int)buflen) {
        debug("OVERFLOW: multirotor spec used %d of %u", used, buflen);
        return nullptr;
    }

    buf = skipline(buf, buflen);

    if (buf == nullptr) {
        debug("no line ending, line is incomplete");
        return nullptr;
    }

    debug("remaining in buf: %d, first char: %c", buflen, buf[0]);

    for (MultirotorGeometryUnderlyingType i = 0; i < (MultirotorGeometryUnderlyingType)MultirotorGeometry::MAX_GEOMETRY;
         i++) {
        if (!strcmp(geomname, _config_key[i])) {
            geometry = (MultirotorGeometry)i;
            break;
        }
    }

    if (geometry == MultirotorGeometry::MAX_GEOMETRY) {
        debug("unrecognised geometry '%s'", geomname);
        return nullptr;
    }

    debug("adding multirotor mixer '%s'", geomname);

    return new MultirotorMixer(
               control_cb,
               cb_handle,
               geometry,
               s[3] / 10000.0f); //corresponds to the last control input, i.e thrust or idle speed
}

float
MultirotorMixer::compute_desaturation_gain(const float *desaturation_vector, const float *outputs,
        saturation_status &sat_status, float min_output, float max_output) const
{
    float k_min = 0.f;
    float k_max = 0.f;

    for (unsigned i = 0; i < _rotor_count; i++) {
        // Avoid division by zero. If desaturation_vector[i] is zero, there's nothing we can do to unsaturate anyway
        if (fabsf(desaturation_vector[i]) < FLT_EPSILON) {
            continue;
        }

        if (outputs[i] < min_output) {
            float k = (min_output - outputs[i]) / desaturation_vector[i];

            if (k < k_min) { k_min = k; }

            if (k > k_max) { k_max = k; }

            sat_status.flags.motor_neg = true;
        }

        if (outputs[i] > max_output) {
            float k = (max_output - outputs[i]) / desaturation_vector[i];

            if (k < k_min) { k_min = k; }

            if (k > k_max) { k_max = k; }

            sat_status.flags.motor_pos = true;
        }
    }

    // Reduce the saturation as much as possible
    return k_min + k_max;
}

void
MultirotorMixer::minimize_saturation(const float *desaturation_vector, float *outputs,
                     saturation_status &sat_status, float min_output, float max_output, bool reduce_only) const
{
    float k1 = compute_desaturation_gain(desaturation_vector, outputs, sat_status, min_output, max_output);

    if (reduce_only && k1 > 0.f) {
        return;
    }

    for (unsigned i = 0; i < _rotor_count; i++) {
        outputs[i] += k1 * desaturation_vector[i];
    }

    // Compute the desaturation gain again based on the updated outputs.
    // In most cases it will be zero. It won't be if max(outputs) - min(outputs) > max_output - min_output.
    // In that case adding 0.5 of the gain will equilibrate saturations.
    float k2 = 0.5f * compute_desaturation_gain(desaturation_vector, outputs, sat_status, min_output, max_output);

    for (unsigned i = 0; i < _rotor_count; i++) {
        outputs[i] += k2 * desaturation_vector[i];
    }
}


void
MultirotorMixer::mix_airmode_disabled(float moment_roll, float moment_pitch, float moment_yaw, float thrust, float *squared_rotor_spd)
{
    //By aightech: In this function you can compute the relation between the moment/thrust and the rotor squared speed.
    //By aightech: all the variable are in SI units


    //By aightech: ######### PX4 original computation ###########
    //By aightech: Almost equivalent to a matrix multiplication between the pseudo inverse of the allocation matrix and the moment/thrust vector.


    // Airmode disabled: never allow to increase the thrust to unsaturate a motor
    // Mix without yaw
    for (unsigned i = 0; i < _rotor_count; i++) {

        squared_rotor_spd[i] = moment_roll * _rotors[i].rotor_roll_allocation_coeff +
                 moment_pitch * _rotors[i].rotor_pitch_allocation_coeff +
                 thrust * _rotors[i].thrust_allocation_coeff;

        // Thrust will be used to unsaturate if needed
        _tmp_array[i] = _rotors[i].thrust_allocation_coeff;
    }

    // only reduce thrust
    minimize_saturation(_tmp_array, squared_rotor_spd, _saturation_status, _min_speed2, _max_speed2, true);

    // Reduce roll/pitch acceleration if needed to unsaturate
    for (unsigned i = 0; i < _rotor_count; i++) {
        _tmp_array[i] = _rotors[i].rotor_roll_allocation_coeff;
    }

    minimize_saturation(_tmp_array, squared_rotor_spd, _saturation_status, _min_speed2, _max_speed2);

    for (unsigned i = 0; i < _rotor_count; i++) {
        _tmp_array[i] = _rotors[i].rotor_pitch_allocation_coeff;
    }

    minimize_saturation(_tmp_array, squared_rotor_spd, _saturation_status, _min_speed2, _max_speed2);

    // Mix yaw independently
    mix_yaw(moment_yaw, squared_rotor_spd);

    //By aightech: ####################################




}

void MultirotorMixer::mix_yaw(float yaw, float *outputs)
{
    // Add yaw to outputs
    for (unsigned i = 0; i < _rotor_count; i++) {
        outputs[i] += yaw * _rotors[i].rotor_yaw_allocation_coeff;

        // Yaw will be used to unsaturate if needed
        _tmp_array[i] = _rotors[i].rotor_yaw_allocation_coeff;
    }

    // Change yaw acceleration to unsaturate the outputs if needed (do not change roll/pitch),
    // and allow some yaw response at maximum thrust
    minimize_saturation(_tmp_array, outputs, _saturation_status, _min_speed2, _max_speed2);

    for (unsigned i = 0; i < _rotor_count; i++) {
        _tmp_array[i] = _rotors[i].thrust_allocation_coeff;
    }

    // reduce thrust only
    minimize_saturation(_tmp_array, outputs, _saturation_status, _min_speed2, _max_speed2, true);
}

unsigned
MultirotorMixer::mix(float *output_sent_to_driver, unsigned space)
{
    //By aightech: Only one array is used but for readibility we use different name depending on the process step.

    float *squared_rotor_spd = output_sent_to_driver;
    float *rotor_spd = output_sent_to_driver;

    if (space < _rotor_count) {
        return 0;
    }

    //By aightech: get the controle and scale it to get approximated SI units
    float torque_roll    = _roll_ctrl_input_to_torque   * math::constrain(get_control(0, 0) , -1.0f, 1.0f);
    float torque_pitch   = _pitch_ctrl_input_to_torque  * math::constrain(get_control(0, 1) , -1.0f, 1.0f);
    float torque_yaw     = _yaw_ctrl_input_to_torque    * math::constrain(get_control(0, 2) , -1.0f, 1.0f);
    float thrust  = _thrust_ctrl_input_to_force  * math::constrain(get_control(0, 3), 0.0f, 1.0f);



    // clean out class variable used to capture saturation
    _saturation_status.value = 0;

    // Do the mixing using the strategy given by the current Airmode configuration

    mix_airmode_disabled(torque_roll, torque_pitch, torque_yaw, thrust, squared_rotor_spd);



    //By aightech: transform the rotor speed into pwm
    // output_sent_to_driver has to be between -1 and 1.
    //When -1, the duty cycle sent to the motor is 0.
    //When 0, , the duty cycle sent to the motor is 0.5.
    //When 1, the duty cycle sent to the motor is 1.
    // THIS IS WERE WE HAVE CONTROL OVER THE DUTY CYCLE
    // Then it is processed by the drivers.


    // we have to reverse this relation : output_sent_to_driver =

    for (unsigned i = 0; i < _rotor_count; i++)
    {
        //By aightech:: root squared the rotor speed.

        rotor_spd[i] = sqrt(squared_rotor_spd[i]);

        //debug("r:%f \t p:%f \t y:%f \t t:%f \t %f \t %f \t %f \t %f\t %f \t %f", double(roll), double(pitch), double(yaw), double(thrust), double(rotor_spd[0]), double(rotor_spd[1]), double(rotor_spd[2]), double(rotor_spd[3]), double(rotor_spd[4]), double(rotor_spd[5]));


        output_sent_to_driver[i] = math::constrain(rotor_spd[i]/motor_constant_in_tr_min_per_volt/battery_level*(PWM_max-PWM_min)+PWM_min,0.0f,PWM_max*0.95f);
        //if (std::isnan(output_sent_to_driver[i])){
        //    output_sent_to_driver[i]=PWM_min*1.05f;

        //}
        //debug("O:%f",double(output_sent_to_driver[0]));

    }

    return _rotor_count;
}

